%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}



\title{Refining Event Labels}
\date{Jul 04, 2019}
\release{}
\author{}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


The source code is available under: \sphinxurl{https://github.com/NicoleVentsch/Refining-Event-Labels}.


\chapter{Module 1 - File Converter}
\label{\detokenize{eventLogConverter:module-1-file-converter}}\label{\detokenize{eventLogConverter::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{FileUtility (class in eventLogConverter.concreteImplementation)@\spxentry{FileUtility}\spxextra{class in eventLogConverter.concreteImplementation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.concreteImplementation.FileUtility}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.concreteImplementation.}}\sphinxbfcode{\sphinxupquote{FileUtility}}}{\emph{defaultDirectory}}{}
\end{fulllineitems}

\index{XESFileConverter (class in eventLogConverter.concreteImplementation)@\spxentry{XESFileConverter}\spxextra{class in eventLogConverter.concreteImplementation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.concreteImplementation.XESFileConverter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.concreteImplementation.}}\sphinxbfcode{\sphinxupquote{XESFileConverter}}}
\end{fulllineitems}

\index{CSVFileConverter (class in eventLogConverter.concreteImplementation)@\spxentry{CSVFileConverter}\spxextra{class in eventLogConverter.concreteImplementation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.concreteImplementation.CSVFileConverter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.concreteImplementation.}}\sphinxbfcode{\sphinxupquote{CSVFileConverter}}}
\end{fulllineitems}

\index{XESFileCreator (class in eventLogConverter.concreteImplementation)@\spxentry{XESFileCreator}\spxextra{class in eventLogConverter.concreteImplementation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.concreteImplementation.XESFileCreator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.concreteImplementation.}}\sphinxbfcode{\sphinxupquote{XESFileCreator}}}
\end{fulllineitems}

\index{FileConverterFactory (class in eventLogConverter.defaultFileHandlersFactory)@\spxentry{FileConverterFactory}\spxextra{class in eventLogConverter.defaultFileHandlersFactory}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.defaultFileHandlersFactory.FileConverterFactory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.defaultFileHandlersFactory.}}\sphinxbfcode{\sphinxupquote{FileConverterFactory}}}
\end{fulllineitems}

\index{FileCreatorFactory (class in eventLogConverter.defaultFileHandlersFactory)@\spxentry{FileCreatorFactory}\spxextra{class in eventLogConverter.defaultFileHandlersFactory}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.defaultFileHandlersFactory.FileCreatorFactory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.defaultFileHandlersFactory.}}\sphinxbfcode{\sphinxupquote{FileCreatorFactory}}}
\end{fulllineitems}

\index{FileHandlerFactory (class in eventLogConverter.fileHandlerBase)@\spxentry{FileHandlerFactory}\spxextra{class in eventLogConverter.fileHandlerBase}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.fileHandlerBase.FileHandlerFactory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.fileHandlerBase.}}\sphinxbfcode{\sphinxupquote{FileHandlerFactory}}}~\index{register() (eventLogConverter.fileHandlerBase.FileHandlerFactory method)@\spxentry{register()}\spxextra{eventLogConverter.fileHandlerBase.FileHandlerFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.fileHandlerBase.FileHandlerFactory.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{fileType}, \emph{fileHandler}}{}
Register a virtual subclass of an ABC.

Returns the subclass, to allow usage as a class decorator.

\end{fulllineitems}


\end{fulllineitems}

\index{FileCreator (class in eventLogConverter.fileHandlerBase)@\spxentry{FileCreator}\spxextra{class in eventLogConverter.fileHandlerBase}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.fileHandlerBase.FileCreator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.fileHandlerBase.}}\sphinxbfcode{\sphinxupquote{FileCreator}}}
\end{fulllineitems}

\index{FileConverter (class in eventLogConverter.fileHandlerBase)@\spxentry{FileConverter}\spxextra{class in eventLogConverter.fileHandlerBase}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.fileHandlerBase.FileConverter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.fileHandlerBase.}}\sphinxbfcode{\sphinxupquote{FileConverter}}}
\end{fulllineitems}

\index{FileUtilityBase (class in eventLogConverter.fileUtility)@\spxentry{FileUtilityBase}\spxextra{class in eventLogConverter.fileUtility}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{eventLogConverter:eventLogConverter.fileUtility.FileUtilityBase}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogConverter.fileUtility.}}\sphinxbfcode{\sphinxupquote{FileUtilityBase}}}{\emph{defaultDirectory}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Module 2 - Preprocessing Log}
\label{\detokenize{preprocessing:module-2-preprocessing-log}}\label{\detokenize{preprocessing::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{DBTool (class in eventLogProcessing.DBTool)@\spxentry{DBTool}\spxextra{class in eventLogProcessing.DBTool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{eventLogProcessing.DBTool.}}\sphinxbfcode{\sphinxupquote{DBTool}}}{\emph{eventLog}}{}
data base class containing the main preprocessing steps and tools used to access the database
\index{getVariants() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getVariants()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getVariants}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getVariants}}}{}{}
get all the variants from the variantTable
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of list of Strings representig all the variants

\end{description}\end{quote}

\end{fulllineitems}

\index{getVariantByID() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getVariantByID()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getVariantByID}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getVariantByID}}}{\emph{vID}}{}
get a variant given a variantID
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vID}} \textendash{} a variantID (integer)

\item[{Returns}] \leavevmode
a list of Strings representig a variant

\end{description}\end{quote}

\end{fulllineitems}

\index{getVariantByEventID() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getVariantByEventID()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getVariantByEventID}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getVariantByEventID}}}{\emph{eID}}{}
get a variant given an eventID
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{eID}} \textendash{} an eventID (integer)

\item[{Returns}] \leavevmode
a list of Strings representig a variant

\end{description}\end{quote}

\end{fulllineitems}

\index{getTracesByVariantID() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getTracesByVariantID()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getTracesByVariantID}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getTracesByVariantID}}}{\emph{vID}}{}
get all traces within a variant given a variantID
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vID}} \textendash{} an variantID (integer)

\item[{Returns}] \leavevmode
a list of integers representig the traces within a variant

\end{description}\end{quote}

\end{fulllineitems}

\index{getEventByID() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getEventByID()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getEventByID}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEventByID}}}{\emph{eID}}{}
get an event given its eID
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{eID}} \textendash{} an eventID (integer)

\item[{Returns}] \leavevmode
an Object representig an event (containing:  EventID, VariantID, Position and Event)

\end{description}\end{quote}

\end{fulllineitems}

\index{getVariantTable() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getVariantTable()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getVariantTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getVariantTable}}}{}{}
get the variantTable
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a pandas DataFrame representing the variantTable

\end{description}\end{quote}

\end{fulllineitems}

\index{getEventVariantTable() (eventLogProcessing.DBTool.DBTool method)@\spxentry{getEventVariantTable()}\spxextra{eventLogProcessing.DBTool.DBTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{preprocessing:eventLogProcessing.DBTool.DBTool.getEventVariantTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEventVariantTable}}}{}{}
get the eventVariantTable
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a pandas DataFrame representing the eventVariantTable

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Module 3 - Cost Function}
\label{\detokenize{cost function:module-3-cost-function}}\label{\detokenize{cost function::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{createEventIDs() (in module costFunction.mappings)@\spxentry{createEventIDs()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.createEventIDs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{createEventIDs}}}{\emph{variants={[}{]}}}{}
assigns a unique ID to each event of a variant given a list of variants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{variants}} \textendash{} list of variants, i.e., a list of lists

\item[{Returns}] \leavevmode
a list of list of tuples (ID,Event), where each ID is unique

\end{description}\end{quote}

\end{fulllineitems}

\index{commonLabels() (in module costFunction.mappings)@\spxentry{commonLabels()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.commonLabels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{commonLabels}}}{\emph{variant1}, \emph{variant2}}{}
creates a list of common event labels between two variants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} second variant as a list of tuples (eventID, event label)

\end{itemize}

\item[{Returns}] \leavevmode
a list of common event labels (without IDs) between the two variants

\end{description}\end{quote}

\end{fulllineitems}

\index{getNumberOfCommonLabels() (in module costFunction.mappings)@\spxentry{getNumberOfCommonLabels()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.getNumberOfCommonLabels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{getNumberOfCommonLabels}}}{\emph{variant1={[}{]}}, \emph{variant2={[}{]}}}{}
gives the number of common event labels between two variants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} second variant as a list of tuples (eventID, event label)

\end{itemize}

\item[{Returns}] \leavevmode
number of common event labels of the two variants

\end{description}\end{quote}

\end{fulllineitems}

\index{getPositionsLabel() (in module costFunction.mappings)@\spxentry{getPositionsLabel()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.getPositionsLabel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{getPositionsLabel}}}{\emph{string}, \emph{variant}}{}
gives a list of all IDs corresponding to a given event label within a given variant
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{string}} \textendash{} event label

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant}} \textendash{} variant as a list of tuples (eventID, event label)

\end{itemize}

\item[{Returns}] \leavevmode
a list of all IDs corresponding to the given event label within the variant

\end{description}\end{quote}

\end{fulllineitems}

\index{possibleMappings() (in module costFunction.mappings)@\spxentry{possibleMappings()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.possibleMappings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{possibleMappings}}}{\emph{variant1={[}{]}}, \emph{variant2={[}{]}}}{}
gives a list of all possible mappings between two given variants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} second variant as a list of tuples (eventID, event label)

\end{itemize}

\item[{Returns}] \leavevmode
a list of all possible mappings between the two variants where a mapping is a set of matched pairs (ID1,ID2), where the event label corresponding to ID1 is the same as that corresponding to ID2; ID1 is from the first variant and ID2 from the second variant

\end{description}\end{quote}

\end{fulllineitems}

\index{positionsOfCandidates() (in module costFunction.mappings)@\spxentry{positionsOfCandidates()}\spxextra{in module costFunction.mappings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.mappings.positionsOfCandidates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.mappings.}}\sphinxbfcode{\sphinxupquote{positionsOfCandidates}}}{\emph{candidates}, \emph{variants}}{}
gives a list of all IDs referring to some candidate label
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{candidates}} \textendash{} set of candidate labels for refinement chosen by the user

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variants}} \textendash{} list of all trace variants in event log where each label has unique ID

\end{itemize}

\item[{Returns}] \leavevmode
a list with all event IDs whose label is in the candidate set

\end{description}\end{quote}

\end{fulllineitems}

\index{costStructure() (in module costFunction.cost)@\spxentry{costStructure()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.costStructure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{costStructure}}}{\emph{variant1}, \emph{variant2}, \emph{mapping}}{}
get the sum of the differences in the distances between each matched pair and other matches pairs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} the first variant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} the second variant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mapping}} \textendash{} the mapping of the actions from the first to the second variant

\end{itemize}

\item[{Returns}] \leavevmode
sum of the differences in the distances

\end{description}\end{quote}

\end{fulllineitems}

\index{context() (in module costFunction.cost)@\spxentry{context()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.context}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{context}}}{\emph{variant}}{}
gives a two list (x,y) for the variant, the first one containing the set of predecessors of each action in the variant and the second one containing the set of successors of each action in the variant
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{variant}} \textendash{} the variant as a list of tuples (eventID, event label) of which we get the list of predecessors and successors

\item[{Returns}] \leavevmode
a tuple (x,y) of lists of sets, where x{[}i{]} is the set of predecessors of label on position i and y{[}i{]} the set of successors of label on position i

\end{description}\end{quote}

\end{fulllineitems}

\index{costNoMatch() (in module costFunction.cost)@\spxentry{costNoMatch()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.costNoMatch}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{costNoMatch}}}{\emph{variant1}, \emph{variant2}, \emph{context1}, \emph{context2}, \emph{mapping}}{}
calculates the cost for labels that are not matched. This cost is given as the sum of the number of their predecessors and successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} the first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} the second variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context1}} \textendash{} predecessors,successors of variant1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context2}} \textendash{} predecessors,successors of variant2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mapping}} \textendash{} the mapping for which the costs for the non-matched labels are calculated

\end{itemize}

\item[{Returns}] \leavevmode
the cost for the non-matched labels

\end{description}\end{quote}

\end{fulllineitems}

\index{costMatched() (in module costFunction.cost)@\spxentry{costMatched()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.costMatched}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{costMatched}}}{\emph{variant1}, \emph{variant2}, \emph{context1}, \emph{context2}, \emph{mapping}}{}
calculates the cost for labels that are matched. This cost is given as the sum of the differences in the direct/indirect neighbors of the matched pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} the first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} the second variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context1}} \textendash{} predecessors,successors of variant1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context2}} \textendash{} predecessors,successors of variant2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mapping}} \textendash{} the mapping for which the costs for the matched labels are calculated

\end{itemize}

\item[{Returns}] \leavevmode
the cost for the matched labels

\end{description}\end{quote}

\end{fulllineitems}

\index{costMapping() (in module costFunction.cost)@\spxentry{costMapping()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.costMapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{costMapping}}}{\emph{cp}, \emph{variant1}, \emph{variant2}, \emph{context1}, \emph{context2}, \emph{mapping}}{}
gives the total cost of a mapping between two variants based on a weighted sum of the structural costs and the costs for matched and non-matched labels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cp}} \textendash{} custom parameters object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant1}} \textendash{} the first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant2}} \textendash{} the second variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context1}} \textendash{} predecessors,successors of variant1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context2}} \textendash{} predecessors,successors of variant2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mapping}} \textendash{} the mapping for which the total cost is calculated

\end{itemize}

\item[{Returns}] \leavevmode
the total cost of the mapping

\end{description}\end{quote}

\end{fulllineitems}

\index{optimalMapping() (in module costFunction.cost)@\spxentry{optimalMapping()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.optimalMapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{optimalMapping}}}{\emph{variant\_i}, \emph{variant\_j}, \emph{i}, \emph{j}, \emph{context\_i}, \emph{context\_j}, \emph{matrixx}, \emph{cp}}{}
given two variants the mapping with the lowest total cost together with the value of this cost will be returned
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant\_i}} \textendash{} the first variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant\_j}} \textendash{} the second variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} index of variant\_i in variants

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{j}} \textendash{} index of variant\_j in variants

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context\_i}} \textendash{} predecessors,successors of variant\_i

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context\_j}} \textendash{} predecessors,successors of variant\_j

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrixx}} \textendash{} matrix that should containing the cost of the mappings (after the function was called)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cp}} \textendash{} custom parameters object

\end{itemize}

\item[{Returns}] \leavevmode
a tuple (mapping, cost) of the mapping with the lowest total cost and the corresponding cost value; a mapping is a set of matched pairs (ID1,ID2), where the event label corresponding to ID1 is the same as that corresponding to ID2; ID1 is from the first variant and ID2 from the second variant

\end{description}\end{quote}

\end{fulllineitems}

\index{bestMappings() (in module costFunction.cost)@\spxentry{bestMappings()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.bestMappings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{bestMappings}}}{\emph{cp}, \emph{variants}, \emph{C}}{}
get the best mappings for the given variants and update the cost matrix, so that it contains the cost for each optimal mapping
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cp}} \textendash{} custom parameters object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variants}} \textendash{} a list of variants

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{C}} \textendash{} the cost matrix that should be updated, so that it contains the costs of the optimal mappings

\end{itemize}

\item[{Returns}] \leavevmode
a list of the best mappings between all combinations of two variants from the given variants

\end{description}\end{quote}

\end{fulllineitems}

\index{context2() (in module costFunction.cost)@\spxentry{context2()}\spxextra{in module costFunction.cost}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cost function:costFunction.cost.context2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{costFunction.cost.}}\sphinxbfcode{\sphinxupquote{context2}}}{\emph{variant}, \emph{k}}{}
creates a list of k predecessors and successors of all events of a given variant
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variant}} \textendash{} variant as a list of tuples (eventID, event label)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} integer specifying the number of predecessors and successors we consider

\end{itemize}

\item[{Returns}] \leavevmode
a list of sets of predecessors and successors of each event within a variant

\end{description}\end{quote}

\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Module 4 - Label Refinement}
\label{\detokenize{refinement:module-4-label-refinement}}\label{\detokenize{refinement::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{connectedComponents() (in module refinement.labelRefinement)@\spxentry{connectedComponents()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.connectedComponents}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{connectedComponents}}}{\emph{G}, \emph{candidateLabels}}{}
computes the connected components given a subgraph 
:param G: a graph object created from the networkx library
:param candidateLabels: a list of Strings representing the candidate lables
:return: a dictionary containing \{candidateLabel: {[}{[}comp1{]},{[}comp2{]},…{]}\}

\end{fulllineitems}

\index{sizelargestComponent() (in module refinement.labelRefinement)@\spxentry{sizelargestComponent()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.sizelargestComponent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{sizelargestComponent}}}{\emph{connectedComponents}}{}
computes the size of the largest components for each candidateLabel
:param connectedComponents: a dictionary containing the connected components created from the method connectedComponents()
:return: a dictionary with the form \{candidateLabel: maxSize({[}{[}comp1{]},{[}comp2{]},…{]})\}

\end{fulllineitems}

\index{averagePosition() (in module refinement.labelRefinement)@\spxentry{averagePosition()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.averagePosition}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{averagePosition}}}{\emph{Gi}, \emph{db}}{}
computes the average position of the events for a given connected component, i.e., \#Gi
:param Gi: a list representing the connected component for a given event {[}{[}comp1{]},{[}comp2{]},…{]}
:param db: a DBTool object
:return: a list with the average position {[}{[}avgPosComp1{]},{[}avgPosComp2{]},…{]}

\end{fulllineitems}

\index{getPosition() (in module refinement.labelRefinement)@\spxentry{getPosition()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.getPosition}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{getPosition}}}{\emph{eID}, \emph{db}}{}
get the position of an event given its eventID
:param eID: an eventID (integer)
:param db: a DBTool object
:return: an integer representig the position of an event within a trace

\end{fulllineitems}

\index{sortConectedComponents() (in module refinement.labelRefinement)@\spxentry{sortConectedComponents()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.sortConectedComponents}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{sortConectedComponents}}}{\emph{connectedComponents}, \emph{db}}{}
sort the connected components in ascending order w.r.t. their average position
:param connectedComponents:  a dictionary containing the connected components created from the method connectedComponents()
:param db: a DBTool object
:return: a dictionary containing the sorted components, i.e., \{candidateLabel: {[}{[}comp1{]},{[}comp2{]},…{]}\}

\end{fulllineitems}

\index{horizontalRefinement() (in module refinement.labelRefinement)@\spxentry{horizontalRefinement()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.horizontalRefinement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{horizontalRefinement}}}{\emph{cp}, \emph{graphList}}{}
perform the horizontal relabeling according to the paper
:param cp:  a customParameters object
:param graphList: a list of graphs created from the networkx library
:return: the same list of graphs but with relebaled event nodes

\end{fulllineitems}

\index{verticalRefinement() (in module refinement.labelRefinement)@\spxentry{verticalRefinement()}\spxextra{in module refinement.labelRefinement}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refinement:refinement.labelRefinement.verticalRefinement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{refinement.labelRefinement.}}\sphinxbfcode{\sphinxupquote{verticalRefinement}}}{\emph{cp}, \emph{graphList}, \emph{db}}{}
perform the vertical relabeling according to the paper
:param cp:  a customParameters object
:param graphList: a list of graphs created from the networkx library
:param db: a DBTool object
:return: the same list of graphs but with relebaled event nodes

\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Homgit statuse}}}}


\chapter{Module 5 - Post-Processing}
\label{\detokenize{postprocessing:module-5-post-processing}}\label{\detokenize{postprocessing::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{eventLogRenaming() (in module eventLogProcessing.postProcessing)@\spxentry{eventLogRenaming()}\spxextra{in module eventLogProcessing.postProcessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{postprocessing:eventLogProcessing.postProcessing.eventLogRenaming}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{eventLogProcessing.postProcessing.}}\sphinxbfcode{\sphinxupquote{eventLogRenaming}}}{\emph{cp}, \emph{subgraphList}, \emph{db}, \emph{eventLog}}{}
function that renames the original event log based on the results of the refinement algorithm
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cp}} \textendash{} a customParameters object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{subgraphList}} \textendash{} a list of graphs created from the networkx library

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{db}} \textendash{} a DBTool object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eventLog}} \textendash{} the original event log provided by the user

\end{itemize}

\item[{Returns}] \leavevmode
the refined event log based on the results of the refinement algorithm

\end{description}\end{quote}

\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Graph Creation}
\label{\detokenize{graph:graph-creation}}\label{\detokenize{graph::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{graphTool (class in graph.graphTool)@\spxentry{graphTool}\spxextra{class in graph.graphTool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{graph.graphTool.}}\sphinxbfcode{\sphinxupquote{graphTool}}}
graph class containing the main functionalities we need for the algorithm

initialization of a graph
\index{createEdgeList() (graph.graphTool.graphTool method)@\spxentry{createEdgeList()}\spxextra{graph.graphTool.graphTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool.createEdgeList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEdgeList}}}{\emph{edges={[}{]}}, \emph{weight=-1}}{}
creates a list of tuples of edges with the corresponding weights given a list of edges and weights
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edges}} \textendash{} edges given as a list of tuples (eventID1,eventID2)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} \textendash{} a weight

\end{itemize}

\item[{Returns}] \leavevmode
a list of tuples (eventID1, eventID2, weight) of edges together with their weight

\end{description}\end{quote}

\end{fulllineitems}

\index{createGraphFromVariants() (graph.graphTool.graphTool method)@\spxentry{createGraphFromVariants()}\spxextra{graph.graphTool.graphTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool.createGraphFromVariants}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createGraphFromVariants}}}{\emph{variants={[}{]}}}{}
updates an empty graph, such that it becomes a weighted graph containing vertices of the form (eventID, event label) and edges of the form (eventID1, eventID2, weight) based on a given list of variants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{variants}} \textendash{} list of variants, where a variant is given as a list of tuples (eventID, event label), i.e., a list of lists of tuples

\end{description}\end{quote}

\end{fulllineitems}

\index{clusterDetection() (graph.graphTool.graphTool method)@\spxentry{clusterDetection()}\spxextra{graph.graphTool.graphTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool.clusterDetection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clusterDetection}}}{\emph{customParams}}{}
clusters the variants based on a given threshold; to do so, edges with a weight above the threshold are deleted from the given graph respresenting the optimal mappings
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{customParams}} \textendash{} custom parameter object containing the threshold the algorithm should use

\item[{Returns}] \leavevmode
list of subgraphs where each subgraph represents a cluster of variants

\end{description}\end{quote}

\end{fulllineitems}

\index{getGraph() (graph.graphTool.graphTool method)@\spxentry{getGraph()}\spxextra{graph.graphTool.graphTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool.getGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getGraph}}}{}{}
function that returns the graph object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
nx.Graph() object

\end{description}\end{quote}

\end{fulllineitems}

\index{addOptimalMappings() (graph.graphTool.graphTool method)@\spxentry{addOptimalMappings()}\spxextra{graph.graphTool.graphTool method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graph:graph.graphTool.graphTool.addOptimalMappings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addOptimalMappings}}}{\emph{bestMappingsList}, \emph{maxCost}, \emph{candidate\_positions}}{}~\begin{quote}

updates the graph by assigning new weights to edges between mapped pairs of candidate labels given a list of all optimal mappings between all variants, the max cost for normalization and the positions of the candidate labels
:param bestMappingsList: a list containing all best mappings and their costs as tuples (best mapping, cost)
:param maxCost: the cost of the best mapping with the highest cost out of all best mappings
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{candidate\_positions}} \textendash{} a list with all IDs corresponding to all candidate labels

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Custom Parameters}
\label{\detokenize{customParameters:custom-parameters}}\label{\detokenize{customParameters::doc}}
\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}
\index{customParameters (class in objects.customParameters)@\spxentry{customParameters}\spxextra{class in objects.customParameters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{objects.customParameters.}}\sphinxbfcode{\sphinxupquote{customParameters}}}{\emph{candidateLabels}, \emph{horizontalThreshold}, \emph{verticalThreshold}, \emph{weightStructure}, \emph{weightMatch}, \emph{weightNoMatch}}{}
class for the custom parameters

initialization function
\index{getCandidateLabels() (objects.customParameters.customParameters method)@\spxentry{getCandidateLabels()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getCandidateLabels}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getCandidateLabels}}}{}{}
function that returns the candidate labels

\end{fulllineitems}

\index{getHorizontalThreshold() (objects.customParameters.customParameters method)@\spxentry{getHorizontalThreshold()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getHorizontalThreshold}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getHorizontalThreshold}}}{}{}
function that returns the horizontal threshold

\end{fulllineitems}

\index{getVerticalThreshold() (objects.customParameters.customParameters method)@\spxentry{getVerticalThreshold()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getVerticalThreshold}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getVerticalThreshold}}}{}{}
function that returns the vertical threshold

\end{fulllineitems}

\index{getStructureWeight() (objects.customParameters.customParameters method)@\spxentry{getStructureWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getStructureWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getStructureWeight}}}{}{}
function that returns the weight structure

\end{fulllineitems}

\index{getNoMatchWeight() (objects.customParameters.customParameters method)@\spxentry{getNoMatchWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getNoMatchWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getNoMatchWeight}}}{}{}
function that returns the weight for not matched pairs

\end{fulllineitems}

\index{getMatchWeight() (objects.customParameters.customParameters method)@\spxentry{getMatchWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.getMatchWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getMatchWeight}}}{}{}
function that returns the weight for matched pairs

\end{fulllineitems}

\index{setcandidateLabels() (objects.customParameters.customParameters method)@\spxentry{setcandidateLabels()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setcandidateLabels}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setcandidateLabels}}}{\emph{candidateLabels}}{}
function that sets the candidate labels

\end{fulllineitems}

\index{setHorizontalThreshold() (objects.customParameters.customParameters method)@\spxentry{setHorizontalThreshold()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setHorizontalThreshold}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setHorizontalThreshold}}}{\emph{horizontalThreshold}}{}
function that sets the horizontal threshold

\end{fulllineitems}

\index{setVerticalThreshold() (objects.customParameters.customParameters method)@\spxentry{setVerticalThreshold()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setVerticalThreshold}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setVerticalThreshold}}}{\emph{verticalThreshold}}{}
function that sets the vertical threshold

\end{fulllineitems}

\index{setStructureWeight() (objects.customParameters.customParameters method)@\spxentry{setStructureWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setStructureWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setStructureWeight}}}{\emph{weightStructure}}{}
function that sets the weight structure

\end{fulllineitems}

\index{setNoMatchWeight() (objects.customParameters.customParameters method)@\spxentry{setNoMatchWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setNoMatchWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setNoMatchWeight}}}{\emph{weightNoMatch}}{}
function that sets the weight for not matched pairs

\end{fulllineitems}

\index{setMatchWeight() (objects.customParameters.customParameters method)@\spxentry{setMatchWeight()}\spxextra{objects.customParameters.customParameters method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{customParameters:objects.customParameters.customParameters.setMatchWeight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setMatchWeight}}}{\emph{weightMatch}}{}
function that sets the weight for matched pairs

\end{fulllineitems}


\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

{\hyperref[\detokenize{index:mastertoc}]{\sphinxcrossref{\DUrole{std,std-ref}{Return Home}}}}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}